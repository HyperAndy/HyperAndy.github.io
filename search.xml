<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode</title>
      <link href="2020/11/08/diary/"/>
      <url>2020/11/08/diary/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="1、前序遍历"><a href="#1、前序遍历" class="headerlink" title="1、前序遍历"></a>1、前序遍历</h2><p>根 -&gt; 左 -&gt; 右</p><ul><li>递归：root.val + func(root.left) + func(root.right)</li><li>迭代: [root] -&gt; stack.pop -&gt; root.right -&gt; root.left<a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 1、递归</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        </span><br><span class="line">        self.res.append(root.val)</span><br><span class="line">        self.preorderTraversal(root.left)</span><br><span class="line">        self.preorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2、迭代</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul><h2 id="2、中序遍历"><a href="#2、中序遍历" class="headerlink" title="2、中序遍历"></a>2、中序遍历</h2><p>左 -&gt; 根 -&gt; 右</p><ul><li>递归：func(root.left) + root.val + func(root.right)</li><li>迭代: 指针滑动，找出所有左子树，pop，保存tmp.val, 赋值右子树</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 1、递归</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.value</span><br><span class="line">        </span><br><span class="line">        self.inorderTraversal(root.left)</span><br><span class="line">        self.value.append(root.val)</span><br><span class="line">        self.inorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2、迭代</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            tmp = stack.pop()</span><br><span class="line">            print(tmp)</span><br><span class="line">            res.append(tmp.val)</span><br><span class="line">            p = tmp.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="3、后序遍历"><a href="#3、后序遍历" class="headerlink" title="3、后序遍历"></a>3、后序遍历</h2><p>左 -&gt; 右 -&gt; 根</p><ul><li>递归：root.val + func(root.right) + func(root.left) 然后反转</li><li>迭代: [root] -&gt; stack.pop -&gt; root.left -&gt; root.right<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 1、递归</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        </span><br><span class="line">        self.postorderTraversal(root.left)</span><br><span class="line">        self.postorderTraversal(root.right)</span><br><span class="line">        self.res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2、迭代</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        tmp = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            item = stack.pop()</span><br><span class="line">            tmp.append(item.val)</span><br><span class="line">            <span class="keyword">if</span> item.left:</span><br><span class="line">                stack.append(item.left)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> item.right:</span><br><span class="line">                stack.append(item.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmp[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ul><h2 id="4、BFS广度遍历-层次遍历"><a href="#4、BFS广度遍历-层次遍历" class="headerlink" title="4、BFS广度遍历(层次遍历)"></a>4、BFS广度遍历(层次遍历)</h2><ul><li>[root] -&gt; [root.left, root.right] -&gt; [tmp.val]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        cur = [root]</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = []</span><br><span class="line">            next_cur = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> cur:</span><br><span class="line">                tmp.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    next_cur.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    next_cur.append(i.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            cur = next_cur</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">lst</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">        key = left</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt;= arr[key]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;= arr[key]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            (arr[left], arr[right]) = (arr[right], arr[left])</span><br><span class="line"></span><br><span class="line">        (arr[left], arr[key]) = (arr[key], arr[left])</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = partition(arr, left, right)</span><br><span class="line">        quicksort(arr, left, mid<span class="number">-1</span>)</span><br><span class="line">        quicksort(arr, mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    quicksort(lst, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="1、快慢指针"><a href="#1、快慢指针" class="headerlink" title="1、快慢指针"></a>1、快慢指针</h2><p>快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。</p><h3 id="1-、判定链表中是否含有环"><a href="#1-、判定链表中是否含有环" class="headerlink" title="(1)、判定链表中是否含有环"></a>(1)、判定链表中是否含有环</h3><ul><li><p>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。</p></li><li><p>如果链表中不包含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。</p></li><li><p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。</p></li><li><p>经典解法就是用两个指针，一个每次前进两步，一个每次前进一步。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p></li></ul><h3 id="2-、已知链表中含有环，返回这个环的起始位置"><a href="#2-、已知链表中含有环，返回这个环的起始位置" class="headerlink" title="(2)、已知链表中含有环，返回这个环的起始位置"></a>(2)、已知链表中含有环，返回这个环的起始位置</h3><ul><li><p>当快慢指针相遇时，让其中任一个指针重新指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？</p></li><li><p>第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）</p></li><li><p>设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。</p></li><li><p>巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点，所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了</p></li></ul><h3 id="3-、寻找链表中间位置"><a href="#3-、寻找链表中间位置" class="headerlink" title="(3)、寻找链表中间位置"></a>(3)、寻找链表中间位置</h3><ul><li>类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置</li></ul><h3 id="4-、寻找链表的倒数第-k-个元素"><a href="#4-、寻找链表的倒数第-k-个元素" class="headerlink" title="(4)、寻找链表的倒数第 k 个元素"></a>(4)、寻找链表的倒数第 k 个元素</h3><ul><li>我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）</li></ul><h2 id="2、左右指针"><a href="#2、左右指针" class="headerlink" title="2、左右指针"></a>2、左右指针</h2><p>左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。</p><ul><li>二分查找</li><li>两数之和（升序数组，找出两数和为目标数值的数）</li><li>反转数组</li><li>滑动窗口算法（这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题）</li></ul><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><a href="https://blog.csdn.net/weixin_41571493/article/details/81875088">https://blog.csdn.net/weixin_41571493/article/details/81875088</a></p><h2 id="1、交换排序"><a href="#1、交换排序" class="headerlink" title="1、交换排序"></a>1、交换排序</h2><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><ul><li><p>顺序比较，每次比较相邻元素，满足条件不交换，不满足条件交换。（每次都会将最值放到队首（尾））</p></li><li><p>时间复杂度O(n^2)，空间复杂度O(1)</p></li></ul><h3 id="1-2-快速排序"><a href="#1-2-快速排序" class="headerlink" title="1.2 快速排序"></a>1.2 快速排序</h3><ul><li><p>选基准值，小的放左，大的放右，基准值将其分为两个分区</p></li><li><p>对两个分区递归的使用相同方法排序</p></li><li><p>时间复杂度O(nlogn)，空间复杂度O(logn)</p></li></ul><h2 id="2、插入排序"><a href="#2、插入排序" class="headerlink" title="2、插入排序"></a>2、插入排序</h2><h3 id="2-1-简单的插入排序"><a href="#2-1-简单的插入排序" class="headerlink" title="2.1 简单的插入排序"></a>2.1 简单的插入排序</h3><ul><li><p>第一个元素开始，可以认为已经被排序</p></li><li><p>取出下一个元素，在已经排好序的前面的序列中从后向前扫描</p></li><li><p>如果扫描的元素大于取出的元素，则其向后移，直到扫描到等于或者小于其的位置，将其放入</p></li><li><p>重复上述步骤</p></li><li><p>时间复杂度O(n^2)，空间复杂度O(1)</p></li></ul><h3 id="2-2-希尔排序"><a href="#2-2-希尔排序" class="headerlink" title="2.2 希尔排序"></a>2.2 希尔排序</h3><ul><li><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序</p></li><li><p>时间复杂度O(nlogn)，空间复杂度O(1)</p></li></ul><h2 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h2><h3 id="3-1-简单选择排序"><a href="#3-1-简单选择排序" class="headerlink" title="3.1 简单选择排序"></a>3.1 简单选择排序</h3><ul><li><p>对数据操作n-1轮，每轮找出一个最大（小）值。</p></li><li><p>操作指选择，即未排序数逐个比较交换，争夺最值位置，每轮将一个未排序位置上的数交换成已排序数，即每轮选一个最值</p></li><li><p>时间复杂度O(n^2)，空间复杂度O(1)</p></li></ul><h3 id="3-2-堆排序"><a href="#3-2-堆排序" class="headerlink" title="3.2 堆排序"></a>3.2 堆排序</h3><ul><li><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p></li><li><p>堆排序的初始建堆过程比价复杂，对O(n)级别个非叶子节点进行堆调整操作O(logn)，时间复杂度O(nlogn)；之后每一次堆调整操作确定一个数的次序，时间复杂度O(nlogn)。合起来时间复杂度O(nlogn)，空间复杂度O(1)</p></li></ul><h2 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h2><h3 id="4-1-二路归并排序"><a href="#4-1-二路归并排序" class="headerlink" title="4.1 二路归并排序"></a>4.1 二路归并排序</h3><ul><li>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</li><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li><li>时间复杂度O(nlogn)</li></ul><h2 id="5、线性时间非比较类排序"><a href="#5、线性时间非比较类排序" class="headerlink" title="5、线性时间非比较类排序"></a>5、线性时间非比较类排序</h2><h3 id="5-1-计数排序"><a href="#5-1-计数排序" class="headerlink" title="5.1 计数排序"></a>5.1 计数排序</h3><ul><li>计数排序用待排序的数值作为计数数组（列表）的下标，统计每个数值的个数，然后依次输出即可</li><li>时间复杂度为O(n+k)，空间复杂度O(n+k), k类</li></ul><h1 id="特征选择的方法"><a href="#特征选择的方法" class="headerlink" title="特征选择的方法"></a>特征选择的方法</h1><p><a href="https://blog.csdn.net/SecondLieutenant/article/details/80693765">https://blog.csdn.net/SecondLieutenant/article/details/80693765</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
